package main

import (
	"log"
)

type Post struct {
	Id    uint64
	Title string
	Html  string
}

type Comment struct {
	Id    uint64
	Title string
	Html  string
}

type IndexItem struct {
    Id uint64
    Depth uint64
}

var posts []Post
var comments []Comment
var index [5][]IndexItem

func get(freshness uint64, start uint64) []IndexItem {
    idxs := index[freshness][start:start + 20]

}

func insert(post Post) {
    post.Id = len(posts)
    posts = append(posts, post)
    i := IndexItem{
        Id: post.Id,
        Depth: 0,
    }
    for j := 0; j < 5; j++ {
        index[j] = append(index[j], i)
    }
}

func insert(comment Comment, parent IndexItem) {
    comment.Id = len(comments)
    comments = append(comments, comment)
    i := IndexItem{
        Id: comment.Id,
        Depth: parent.depth + 1,
    }
    for j := 0; j < 5; j++ {
        index[j] = append(index[j], i)
    }
}

//TODO how to get from a comment/post Id to the place where it needs to be inserted in the index?
//have to loop through the whole index looking for an id...
//this is the major downside to this approach
//theres no way around it, but it can be faster with a binary/interpolated search
//theres never going to be a perfect way around this
//and its better to be on the insert side than the get side

//get slice of posts from one of the indexes
//get all comments of one post
//search text of comments/posts
//insert post
//insert comment, need to be able to find the position in the recursive index from the parent commend id

var posts []Post
var comments [][]Comment
var posts_index[5][]uint64
var comments_index[5][][]uint64

have an immutable array of posts and comments, append only
have the freshness indexes store an index into these arrays
freshness index needs to be kept sorted, to slice posts/comments for rendering
freshness index also needs to be fast find and insert, for commenting
when you render the page, you have the information about the ancestors of the comment
maybe this is the best we can do, the only thing that wont change is the list of ancestors
but we would still have to search through the children at each level

maybe if we have the perfect db architecture we wont need huge complex caches... maybe
